<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸€å¤œç‹¼äººæ®º - å•¤ç‰Œé…’</title>
    <link rel="stylesheet" href="style.css">
    <style>
        /* Specific styles for onenight-werewolf.html */
        body {
            background-color: var(--dpd-bg-dark);
            color: var(--dpd-text-light);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Start from top */
            min-height: 100vh;
            padding: 20px;
            text-align: center;
            box-sizing: border-box; /* Include padding in element's total width and height */
        }

        h1, h2, h3, .game-card h3 {
            font-family: 'Noto Sans TC', -apple-system, BlinkMacSystemFont, sans-serif;
            font-weight: 700;
            color: #10b981; /* ä¸»é ç¶ è‰² */
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            letter-spacing: 0.5px;
        }
        .game-card {
            background: linear-gradient(145deg, #047857, #065f46);
            border: 3px solid #10b981;
            box-shadow: 0 8px 25px rgba(16,185,129,0.3);
        }

        /* Original h1 style, now part of the more general rule above. */
        /* The game-section styles need to be adjusted to green theme */
        /* New .setup-section styles */
        .setup-section {
            background: linear-gradient(135deg, #0f766e, #115e59);
            padding: 25px;
            border-radius: 20px;
            border: 3px solid #10b981;
            box-shadow: 0 15px 40px rgba(16,185,129,0.3);
            margin: 20px 0;
            width: 90%; /* Maintain width from game-section base */
            max-width: 700px;
            box-sizing: border-box;
        }

        /* .game-section (general card style) to be applied to other sections */
        .game-section {
            background: linear-gradient(145deg, #047857, #065f46);
            border-radius: 20px;
            box-shadow: 0 8px 25px rgba(16,185,129,0.3);
            padding: 30px;
            margin-bottom: 20px;
            width: 90%;
            max-width: 700px;
            box-sizing: border-box;
        }


        /* Adjusting existing h1 related styles: */
        /* The original h1 specific color/font-size will be overridden by the new general rule. */
        /* Other elements need to align with the new color scheme. */
        h1 {
            font-size: 2.5em; /* Keep size consistent with previous h1 */
            margin-bottom: 20px;
        }
        .game-section h2 {
            color: #10b981; /* Use the new main green color */
            font-size: 1.8em;
            margin-top: 0;
            margin-bottom: 20px;
            border-bottom: 2px solid #065f46; /* A slightly darker green for accent */
            padding-bottom: 10px;
            display: inline-block;
        }

        /* Re-align other color usages to the new theme */

        /* was --accent-warm-yellow*/
        .player-card h3, .center-card h3, .role-card h3 {
            color: #fbc02d; /* Retain a warm yellow if it's used for contrast, or change to green variant */
        }

        /* was --dpd-border-gray*/
        .game-button:disabled {
            background-color: #065f46; /* Use a green variant */
        }

        /* was --accent-warm-yellow*/
        .player-count-selector button.active, .config-button.active {
            background-color: #fbc02d; /* Retain warm yellow for active button for contrast */
            color: var(--dpd-bg-dark);
        }

        /* was --accent-warm-yellow*/
        #results-banner {
            color: #fbc02d;
            background-color: #047857; /* Use green from game-card background for banner */
        }



        .game-section h2 {
            color: var(--accent-dark-green); /* Green accent for section titles */
            font-size: 1.8em;
            margin-top: 0;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--accent-dark-green);
            padding-bottom: 10px;
            display: inline-block;
        }

        /* Base button style (now specific config buttons will inherit/override) */
        .btn {
            display: inline-block;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            font-size: 18px;
            transition: all 0.3s;
            cursor: pointer;
            text-decoration: none; /* Ensure it works for <a> as well */
            margin: 5px; /* Default margin */
        }

        .btn:hover {
            transform: translateY(-2px);
        }
        .btn:disabled {
            background: #6c757d;
            box-shadow: none;
            cursor: not-allowed;
            transform: none;
        }

        /* Specific config button styling */
        .config-btn {
            padding: 12px 25px;
            margin: 0 10px;
            border: none;
            border-radius: 50px; /* More rounded */
            font-weight: 700;
            font-size: 16px;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .night-phase {
            background: linear-gradient(135deg, #1e3a8a, #1e40af);
            padding: 30px;
            border-radius: 25px;
            margin: 20px 0;
            border: 4px solid #3b82f6;
            width: 90%; /* Match game-section container width */
            max-width: 700px;
            box-sizing: border-box;
        }

        .night-phase .night-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px; /* Space between night action buttons */
            margin-top: 20px;
        }

        .night-phase .night-btn {
            flex: 1;
            padding: 18px;
            margin: 8px;
            background: rgba(255,255,255,0.1);
            color: white;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 15px;
            font-size: 16px;
            font-weight: 600;
            backdrop-filter: blur(10px); /* For a glassy effect if possible */
            transition: all 0.3s;
            cursor: pointer;
            min-width: 100px; /* Ensure buttons are not too small */
        }

        .night-phase .night-btn:hover {
            background: rgba(255,255,255,0.2); 
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);            
        }

        .night-phase .night-btn:disabled {
            background: #6c757d;
            color: #ccc;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .night-phase .night-btn.executed-skill {
            opacity: 0.7; /* Dim out executed skills */
            background: linear-gradient(45deg, #495057, #6c757d); /* Gray out executed buttons */
            cursor: default;
        }

        .night-phase .night-btn.skipped-skill {
            opacity: 0.5;
            background: linear-gradient(45deg, #adb5bd, #ced4da); /* Lighter gray for skipped */
            color: #343a40;
            cursor: default;
        }

        .config-btn.green {
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
        }
        .config-btn.blue {
            background: linear-gradient(45deg, #3b82f6, #2563eb);
            color: white;
        }
        .config-btn.gold {
            background: linear-gradient(45deg, #facc15, #eab308);
            color: #1f2937;
        }

        .config-btn:hover {
             filter: brightness(1.1); /* Slightly brighter on hover */
             transform: translateY(-2px);
             box-shadow: 0 8px 20px rgba(0,0,0,0.4); /* Enhanced shadow on hover */
        }
        .config-btn:disabled {
            background: #6c757d;
            color: #ccc;
            cursor: not-allowed;
            box-shadow: none;
        }

        .night-phase {
            background: linear-gradient(135deg, #1e3a8a, #1e40af);
            padding: 30px;
            border-radius: 25px;
            margin: 20px 0;
            border: 4px solid #3b82f6;
            width: 90%; /* Match game-section container width */
            max-width: 700px;
            box-sizing: border-box;
        }

        .night-phase .night-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px; /* Space between night action buttons */
            margin-top: 20px;
        }

        .night-phase .night-btn {
            flex: 1;
            padding: 18px;
            margin: 8px;
            background: rgba(255,255,255,0.1);
            color: white;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 15px;
            font-size: 16px;
            font-weight: 600;
            backdrop-filter: blur(10px); /* For a glassy effect if possible */
            transition: all 0.3s;
            cursor: pointer;
            min-width: 100px; /* Ensure buttons are not too small */
        }

        .night-phase .night-btn:hover {
            background: rgba(255,255,255,0.2); 
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);            
        }

        .night-phase .night-btn:disabled {
            background: #6c757d;
            color: #ccc;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .night-phase .night-btn.executed-skill {
            opacity: 0.7; /* Dim out executed skills */
            background: linear-gradient(45deg, #495057, #6c757d); /* Gray out executed buttons */
            cursor: default;
        }

        .night-phase .night-btn.skipped-skill {
            opacity: 0.5;
            background: linear-gradient(45deg, #adb5bd, #ced4da); /* Lighter gray for skipped */
            color: #343a40;
            cursor: default;
        }

        .night-phase {
            background: linear-gradient(135deg, #1e3a8a, #1e40af);
            padding: 30px;
            border-radius: 25px;
            margin: 20px 0;
            border: 4px solid #3b82f6;
            width: 90%; /* Match game-section container width */
            max-width: 700px;
            box-sizing: border-box;
        }

        .night-phase .night-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px; /* Space between night action buttons */
            margin-top: 20px;
        }

        .night-phase .night-btn {
            flex: 1;
            padding: 18px;
            margin: 8px;
            background: rgba(255,255,255,0.1);
            color: white;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 15px;
            font-size: 16px;
            font-weight: 600;
            backdrop-filter: blur(10px); /* For a glassy effect if possible */
            transition: all 0.3s;
            cursor: pointer;
        }

        .night-phase .night-btn:hover {
            background: rgba(255,255,255,0.2); 
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);            
        }


        /* For player count and config buttons, use btn-small */
        /* Specific styles for player view cards (button inside it) */
        .player-card .view-card-btn {
            background: linear-gradient(45deg, #10b981, #059669); /* Green from play-btn */
            color: #fff;
            border: none;
            padding: 8px 15px;
            font-size: 0.9em;
            font-weight: bold;
            border-radius: 20px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            margin-top: 10px; /* Keep margin */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .player-card .view-card-btn:hover {
            filter: brightness(1.1); /* Match config-btn hover */
            transform: translateY(-2px);
        }



        #player-list, #center-cards, #night-actions, #voting-area, #results {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
        }

        .player-card, .center-card, .role-card {
            background-color: var(--dpd-card-bg-darker);
            border: 1px solid var(--dpd-border-gray);
            border-radius: 10px;
            padding: 15px;
            margin: 10px;
            min-width: 120px;
            text-align: center;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
            cursor: pointer; /* For player cards to be clickable */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
        }
        .center-card, .role-card {
             cursor: default; /* Center cards and role cards are not for clicking */
        }

        .player-card h3, .center-card h3, .role-card h3 {
            color: var(--accent-warm-yellow);
            margin-top: 0;
            margin-bottom: 10px;
        }

        .player-card p, .center-card p, .role-card p {
            font-size: 0.9em;
            color: var(--dpd-text-light);
            word-break: break-word; /* Ensure long role names wrap */
        }

        .hidden-role {
            background-color: #555;
            color: #ccc;
        }

        /* Night actions buttons */

        .night-phase .night-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px; /* Space between night action buttons */
            margin-top: 20px;
        }

        .night-phase .night-btn {
            padding: 12px 20px; /* Slightly larger for better tap target */
            font-size: 1em; /* Adjusted font size */
            font-weight: 600;
            border-radius: 25px; /* More rounded */
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
            border: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transition: all 0.2s;
            cursor: pointer;
        }

        .night-phase .night-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.3);
        }

        .night-phase .night-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        /* Night actions buttons (active/executed state) */
        .night-phase .night-btn.executed-skill {
            opacity: 0.7; /* Dim out executed skills */
            background: linear-gradient(45deg, #495057, #6c757d); /* Gray out executed buttons */
            cursor: default;
        }

        .night-phase .night-btn.skipped-skill {
            opacity: 0.5;
            background: linear-gradient(45deg, #adb5bd, #ced4da); /* Lighter gray for skipped */
            color: #343a40;
            cursor: default;
        }

        /* .game-button will be replaced with .btn or .config-btn */
        #night-actions .game-button { /* Keep this for now to match old style if used elsewhere */ 
            min-width: 100px;
            margin: 5px;
        }
        
        #discussion-area textarea {
            width: 100%;
            height: 100px;
            background-color: #333;
            color: var(--dpd-text-light);
            border: 1px solid var(--dpd-border-gray);
            border-radius: 8px;
            padding: 10px;
            font-size: 1em;
            box-sizing: border-box;
            margin-top: 10px;
        }

        #voting-selection {
            margin-top: 15px;
        }

        #voting-selection select {
            padding: 8px 10px;
            border-radius: 5px;
            border: 1px solid var(--dpd-border-gray);
            background-color: #333;
            color: var(--dpd-text-light);
            font-size: 1em;
            margin-right: 10px;
        }

        .night-skill-options {
            margin-top: 15px;
            border-top: 1px dashed var(--dpd-border-gray);
            padding-top: 15px;
        }

        .night-skill-options label {
            margin-right: 10px;
            font-weight: bold;
            color: var(--dpd-text-light);
        }

        .night-skill-options select {
            padding: 5px 8px;
            border-radius: 5px;
            border: 1px solid var(--dpd-border-gray);
            background-color: #333;
            color: var(--dpd-text-light);
            font-size: 0.9em;
            margin-right: 10px;
        }

        .night-skill-options button {
            padding: 8px 15px;
            font-size: 0.9em;
        }

        #results-banner {
            font-size: 2.5em;
            color: var(--accent-warm-yellow);
            margin-top: 30px;
            padding: 20px;
            background-color: var(--accent-dark-green);
            border-radius: 15px;
            text-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        }

        footer {
            margin-top: 40px;
            margin-bottom: 20px;
            color: #888;
            font-size: 0.9em;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            h1 {
                font-size: 2em;
            }
            .game-section {
                padding: 20px;
            }
            .game-section h2 {
                font-size: 1.5em;
            }
            .game-button, .player-card, .role-display {
                padding: 10px 20px;
                font-size: 1em;
            }
            .player-count-selector button, .config-button {
                padding: 8px 12px;
                font-size: 0.9em;
            }
            .player-card, .center-card, .role-card {
                min-width: 100px;
                padding: 10px;
                margin: 5px;
            }
            .player-card h3, .center-card h3, .role-card h3 {
                font-size: 1.1em;
            }
            .player-card p, .center-card p, .role-card p {
                font-size: 0.8em;
            }
            #results-banner {
                font-size: 1.8em;
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-button">è¿”ä¸»é </a>
    <h1>ä¸€å¤œç‹¼äººæ®º (6äºº)</h1>


    <!-- éšæ®µ1ï¼šæº–å‚™å€ç¾åŒ– -->
    <div class="setup-section">
      <h2>æº–å‚™</h2>

      <div class="player-config">
        <label for="playerCount">ç©å®¶äººæ•¸</label>
        <select id="playerCount">
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
          <option value="6" selected>6</option>
          <option value="7">7</option>
          <option value="8">8</option>
          <option value="9">9</option>
          <option value="10">10</option>
        </select>
      </div>

      <div class="player-names">
        <input type="text" placeholder="ç©å®¶1" id="p1name">
        <input type="text" placeholder="ç©å®¶2" id="p2name">
        <input type="text" placeholder="ç©å®¶3" id="p3name">
        <input type="text" placeholder="ç©å®¶4" id="p4name">
        <input type="text" placeholder="ç©å®¶5" id="p5name">
        <input type="text" placeholder="ç©å®¶6" id="p6name">
        <input type="text" placeholder="ç©å®¶7" id="p7name">
        <input type="text" placeholder="ç©å®¶8" id="p8name">
        <input type="text" placeholder="ç©å®¶9" id="p9name">
        <input type="text" placeholder="ç©å®¶10" id="p10name">
      </div>


      <div class="player-names">
        <input type="text" placeholder="ç©å®¶1" id="p1name">
        <input type="text" placeholder="ç©å®¶2" id="p2name">
        <input type="text" placeholder="ç©å®¶3" id="p3name">
        <input type="text" placeholder="ç©å®¶4" id="p4name">
        <input type="text" placeholder="ç©å®¶5" id="p5name">
        <input type="text" placeholder="ç©å®¶6" id="p6name">
        <input type="text" placeholder="ç©å®¶7" id="p7name">
        <input type="text" placeholder="ç©å®¶8" id="p8name">
        <input type="text" placeholder="ç©å®¶9" id="p9name">
        <input type="text" placeholder="ç©å®¶10" id="p10name">
      </div>

      <div class="player-names">
        <input type="text" placeholder="ç©å®¶1" id="p1name">
        <input type="text" placeholder="ç©å®¶2" id="p2name">
        <input type="text" placeholder="ç©å®¶3" id="p3name">
        <input type="text" placeholder="ç©å®¶4" id="p4name">
        <input type="text" placeholder="ç©å®¶5" id="p5name">
        <input type="text" placeholder="ç©å®¶6" id="p6name">
        <input type="text" placeholder="ç©å®¶7" id="p7name">
        <input type="text" placeholder="ç©å®¶8" id="p8name">
        <input type="text" placeholder="ç©å®¶9" id="p9name">
        <input type="text" placeholder="ç©å®¶10" id="p10name">
      </div>
      
      <div class="config-buttons">
        <button class="config-btn green" id="recommended-config-button">æ¨è–¦é…ç½®</button>
        <button class="config-btn blue" id="custom-config-button">è‡ªè¨‚é…ç½®</button>
        <button class="config-btn gold" id="deal-cards-button">âœ¨ç™¼ç‰Œâœ¨</button>
      </div>
      <div class="game-buttons" style="margin-top:20px;">
        <button id="shuffle-distribute-button" class="config-btn blue" disabled>æ´—ç‰Œåˆ†é…</button>
        <button id="reveal-all-button" class="config-btn green" disabled>äº®æ‰€æœ‰ç‰Œ</button>
      </div>
    </div>

    <!-- åŸæœ‰çš„ç‰Œå †å’Œåˆ†é…éƒ¨åˆ†èª¿æ•´ç‚ºæ–°çš„çµæ§‹ -->
    <div id="card-pile-section" class="game-section">
        <h2>ç‰Œå † (9å¼µ)</h2>
        <div id="ç‰Œå †" style="display:flex; flex-wrap:wrap; justify-content:center; min-height: 100px;">
            <!-- æŠ½åˆ°çš„9å¼µç‰Œæœƒé¡¯ç¤ºå–ºåº¦ -->
        </div>
    </div>

     <div id="distribution-section" class="game-section" style="display:none;">
        <h2>åˆ†é…</h2>
        <div id="åˆ†é…" style="display:flex; flex-wrap:wrap; justify-content:center; min-height: 250px;">
            <!-- ç©å®¶åŒæ¡Œé¢ç‰Œæœƒé¡¯ç¤ºå–ºåº¦ -->
        </div>
        <p id="result-message" style="margin-top:20px; font-size:1.5em; color: var(--accent-warm-yellow);"></p>
    </div>

    <!-- éšæ®µ2ï¼šç§çœ‹èº«ä»½ -->
    <div id="private-view-section" class="game-section" style="display:none;">
        <h2>ç§çœ‹èº«ä»½</h2>
        <div id="player-view-cards" style="display:flex; flex-wrap:wrap; justify-content:center;">
            <!-- Player cards for private viewing -->
        </div>
        <button id="night-phase-button" class="config-btn blue" style="margin-top:20px;">é€²å…¥å¤œæ™š</button>
    </div>

    <!-- éšæ®µ3ï¼šå¤œæ™šè¡Œå‹• -->
    <div id="night-phase-section" class="night-phase" style="display:none;">
        <h2>å¤œæ™šè¡Œå‹•</h2>
        <div class="night-buttons" id="night-actions">
            <!-- Night action buttons will be populated here -->
        </div>
        <div id="skill-action-area" class="night-skill-options" style="display:none;">
            <p id="skill-description"></p>
            <div id="skill-targets">
                <!-- Skill specific targeting options (players, center cards) -->
            </div>
            <button id="confirm-skill-button" class="config-btn green">ç¢ºèªè¡Œå‹•</button>
            <button id="skip-skill-button" class="config-btn blue">è·³é</button>
        </div>
        <button id="day-phase-button" class="config-btn gold" style="display:none; margin-top:20px;">é€²å…¥ç™½å¤©</button>
    </div>

    <!-- éšæ®µ4ï¼šç™½å¤©è¨è«–èˆ‡æŠ•ç¥¨ -->
    <div id="day-phase-section" class="game-section" style="display:none;">
        <h2>ç™½å¤©è¨è«–èˆ‡æŠ•ç¥¨</h2>
        <div id="discussion-area">
            <textarea placeholder="å¤§å®¶è¨è«–ä¸‹å•¦..."></textarea>
        </div>
        <div id="voting-area" style="margin-top:20px;">
            <h3>æŠ•ç¥¨ç’°ç¯€</h3>
            <div id="voting-selection">
                <label for="vote-target">æŠ•é‚Šå€‹: </label>
                <select id="vote-target">
                    <!-- Player options will be populated here -->
                </select>
                <button id="cast-vote-button" class="config-btn green">æŠ•ç¥¨ (ç©å®¶1)</button>
            </div>
            <div id="final-votes" style="margin-top:20px; display:none;">
                <p>æŠ•ç¥¨çµæœ:</p>
                <ul id="vote-counts" style="list-style-type: none; padding:0;"></ul>
                <button id="show-results-button" class="config-btn gold">é¡¯ç¤ºçµæœ</button>
            </div>
        </div>
    </div>

    <!-- éšæ®µ5ï¼šçµæœé¡¯ç¤º -->
    <div id="results-section" class="game-section" style="display:none;">
        <h2>éŠæˆ²çµæœ</h2>
        <div id="final-roles" style="display:flex; flex-wrap:wrap; justify-content:center;">
            <!-- Final roles and center cards will be displayed here -->
        </div>
        <p id="results-banner" style="margin-top:20px; font-size:1.8em; font-weight:bold;"></p>
        <button id="restart-game-button" class="config-btn blue" style="margin-top:20px;">é‡æ–°é–‹å§‹</button>
    </div>

    <details style="margin-top: 30px; width: 90%; max-width: 700px;" class="game-section">
        <summary style="font-size: 1.2em; font-weight: bold; color: var(--accent-warm-yellow); cursor: pointer; padding: 10px 0;">è§’è‰²é€ŸæŸ¥</summary>
        <div id="skill-list" style="text-align: left; padding-top: 10px;">
            <!-- Skills will be populated here by JS -->
        </div>
    </details>

    <footer>
        <p>å•¤ç‰Œé…’ gameğŸ» - ä¸€å¤œç‹¼äººæ®º</p>
    </footer>

    <script>
        const ROLES_ARRAY = ['æ‘æ°‘','æ‘æ°‘','æ‘æ°‘','ç‹¼äºº','ç‹¼äºº','é è¨€å®¶','å¼·ç›œ','æ—è›‹é¬¼','çš®åŒ ','é…’é¬¼','çµäºº','å®ˆå¤œäºº','å®ˆå¤œäºº','å¤±çœ è€…','çˆªç‰™','åŒ–èº«å¹½éˆ'];
        const SKILLS = {
            'åŒ–èº«å¹½éˆ':'é¸1ç©å®¶è¤‡è£½èº«ä»½+å‹æ¢ä»¶',
            'ç‹¼äºº':'äº’èªéšŠå‹(ç¨ç‹¼çœ‹æ¡Œ1å¼µ)',
            'çˆªç‰™':'çŸ¥ç‹¼ä½ç½®(ç„¡ç‹¼æ™‚ä»»ä¸€æ­»=å‹)',
            'å®ˆå¤œäºº':'çŸ¥å¦ä¸€å®ˆå¤œäºº',
            'é è¨€å®¶':'æŸ¥1ç©å®¶æˆ–æ¡Œ2å¼µ',
            'å¼·ç›œ':'å¯æ›1ç©å®¶èº«ä»½+æŸ¥çœ‹',
            'æ—è›‹é¬¼':'æ›2ç©å®¶èº«ä»½',
            'é…’é¬¼':'ç›²æ›æ¡Œ1å¼µ',
            'å¤±çœ è€…':'é‡çœ‹è‡ªå·±',
            'çš®åŒ ':'æ­»ç„¡ç‹¼æ­»=ç¨å‹',
            'çµäºº':'æ­»å¸¶æœ€å¤šæŠ•è€…',
            'æ‘æ°‘':'ç„¡'
        };

        const RECOMMENDED_CONFIGS = {
            4: ['ç‹¼äºº', 'ç‹¼äºº', 'é è¨€å®¶', 'å¼·ç›œ', 'æ—è›‹é¬¼', 'é…’é¬¼', 'æ‘æ°‘'],
            5: ['ç‹¼äºº', 'ç‹¼äºº', 'é è¨€å®¶', 'å¼·ç›œ', 'æ—è›‹é¬¼', 'é…’é¬¼', 'å¤±çœ è€…', 'æ‘æ°‘'],
            6: ['åŒ–èº«å¹½éˆ', 'ç‹¼äºº', 'ç‹¼äºº', 'é è¨€å®¶', 'å¼·ç›œ', 'æ—è›‹é¬¼', 'é…’é¬¼', 'å¤±çœ è€…', 'æ‘æ°‘'],
            7: ['åŒ–èº«å¹½éˆ', 'ç‹¼äºº', 'ç‹¼äºº', 'é è¨€å®¶', 'å¼·ç›œ', 'æ—è›‹é¬¼', 'é…’é¬¼', 'å¤±çœ è€…', 'æ‘æ°‘', 'çš®åŒ '],
            8: ['åŒ–èº«å¹½éˆ', 'ç‹¼äºº', 'ç‹¼äºº', 'é è¨€å®¶', 'å¼·ç›œ', 'æ—è›‹é¬¼', 'é…’é¬¼', 'å¤±çœ è€…', 'æ‘æ°‘', 'çš®åŒ ', 'çˆªç‰™', 'çµäºº'],
            9: ['åŒ–èº«å¹½éˆ', 'ç‹¼äºº', 'ç‹¼äºº', 'é è¨€å®¶', 'å¼·ç›œ', 'æ—è›‹é¬¼', 'é…’é¬¼', 'å¤±çœ è€…', 'æ‘æ°‘', 'çš®åŒ ', 'çˆªç‰™', 'çµäºº', 'å®ˆå¤œäºº']
        };

        let state = {
            players: [], // [{ id: 'p1', name: 'ç©å®¶1', initialRole: '', currentRole: '', hasViewed: false, voteFor: null }]
            centerCards: [], // [{ id: 'c1', role: '' }]
            rolesInPlay: [], // All N+3 roles for the current game
            nightOrder: ['åŒ–èº«å¹½éˆ', 'ç‹¼äºº', 'çˆªç‰™', 'å®ˆå¤œäºº', 'é è¨€å®¶', 'å¼·ç›œ', 'æ—è›‹é¬¼', 'é…’é¬¼', 'å¤±çœ è€…'],
            currentPhase: 'setup', // 'setup', 'privateView', 'night', 'day', 'results'
            activePlayerIndex: 0,
            activeNightSkillIndex: 0,
            votes: {}, // { 'player_id': count }
            dead: [], // [{ playerId: 'pX', role: 'Role' }]
            messages: [] // For game log/discussion
        };

        let playerCount = 6; // Default to 6 players

        // Utility Functions
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function getRoleDisplayName(role) {
            return role === 'æ‘æ°‘' ? 'æ‘æ°‘' : role; // Simplify for some roles if needed
        }

        // UI Update Functions
        function renderRoleSkills() {
            const skillListDiv = document.getElementById('skill-list');
            skillListDiv.innerHTML = '';
            for (const role in SKILLS) {
                const p = document.createElement('p');
                p.innerHTML = `<strong style="color: var(--accent-warm-yellow);">${role}:</strong> ${SKILLS[role]}`;
                skillListDiv.appendChild(p);
            }
        }

        function updatePlayerCount(count) {
            playerCount = count;
            // Update the display for player count in setup section
            document.getElementById('playerCount').value = count; // This targets the select element directly

            // Hide/show player name input fields based on count
            for (let i = 1; i <= 10; i++) {
                const input = document.getElementById(`p${i}name`);
                if (input) {
                    input.style.display = i <= count ? 'block' : 'none';
                }
            }

            // Highlight recommended config button if applicable
            document.querySelectorAll('.config-btn').forEach(btn => btn.classList.remove('active'));
            const recommendedBtn = document.querySelector(`#recommended-config-button[data-player-count="${count}"]`);
            if (recommendedBtn) {
                recommendedBtn.classList.add('active');
                loadRecommendedConfig(count);
            } else {
                document.getElementById('ç‰Œå †').innerHTML = ''; // Clear if custom config needed
            }
             updateGameButtons();
        }

        function updateGameButtons() {
            const dealCardsButton = document.getElementById('deal-cards-button');
            const shuffleDistributeButton = document.getElementById('shuffle-distribute-button');
            const revealAllButton = document.getElementById('reveal-all-button');

            dealCardsButton.disabled = playerCount < 3 || state.rolesInPlay.length === 0;
            shuffleDistributeButton.disabled = state.players.length === 0 || state.currentPhase === 'playing'; // After cards are dealt
            revealAllButton.disabled = state.players.length === 0;
        }

        function dealCards() {
            // Logic to draw N+3 cards and display them in the 'ç‰Œå †' section
            const drawnRoles = RECOMMENDED_CONFIGS[playerCount] || []; // Use recommended or a default
            state.rolesInPlay = [...drawnRoles]; // Copy roles for this game session

            const cardPileDiv = document.getElementById('ç‰Œå †');
            cardPileDiv.innerHTML = ''; // Clear previous cards
            state.rolesInPlay.forEach(role => {
                const cardDiv = document.createElement('div');
                cardDiv.classList.add('role-card');
                cardDiv.innerHTML = `<h3>${getRoleDisplayName(role)}</h3>`;
                cardPileDiv.appendChild(cardDiv);
            });
            document.getElementById('deal-cards-button').disabled = true; // Disable after dealing
            document.getElementById('shuffle-distribute-button').disabled = false; // Enable shuffle/distribute
        }


        function displayDrawnCards() {
            const drawnCardsDiv = document.getElementById('ç‰Œå †'); // Use 'ç‰Œå †' for drawn cards
            drawnCardsDiv.innerHTML = '';
            state.rolesInPlay.forEach(role => {
                const cardDiv = document.createElement('div');
                cardDiv.classList.add('role-card');
                cardDiv.innerHTML = `<h3>${getRoleDisplayName(role)}</h3>`;
                drawnCardsDiv.appendChild(cardDiv);
            });
        }

        function displayPlayerViewCards() {
            const playerViewDiv = document.getElementById('player-view-cards');
            playerViewDiv.innerHTML = '';
            state.players.forEach(player => {
                const cardDiv = document.createElement('div');
                cardDiv.classList.add('player-card');
                cardDiv.dataset.playerId = player.id;
                cardDiv.innerHTML = `<h3>${player.name}</h3><p>èº«ä»½: ???</p><button class="view-card-btn" data-player-id="${player.id}">ç‡ç‰Œ</button>`;
                playerViewDiv.appendChild(cardDiv);
            });
        }

        function setupNightActions() {
            const nightActionsDiv = document.getElementById('night-actions');
            nightActionsDiv.innerHTML = '';
            state.nightOrder.forEach(role => {
                const button = document.createElement('button');
                button.classList.add('night-btn'); // Changed from game-button to night-btn
                button.textContent = role;
                button.dataset.role = role;
                button.addEventListener('click', () => activateNightSkill(role));
                nightActionsDiv.appendChild(button);
            });
             // day-phase-button is now part of the night-phase-section HTML
        }

        function setupVotingOptions() {
            const voteTargetSelect = document.getElementById('vote-target');
            voteTargetSelect.innerHTML = '';
            state.players.forEach(player => {
                const option = document.createElement('option');
                option.value = player.id;
                option.textContent = player.name;
                voteTargetSelect.appendChild(option);
            });
        }

        function revealAllRoles() {
            // Reveal all player roles and center cards
            const finalRolesDiv = document.getElementById('final-roles');
            finalRolesDiv.innerHTML = '';
            state.players.forEach(player => {
                const cardDiv = document.createElement('div');
                cardDiv.classList.add('player-card');
                cardDiv.innerHTML = `<h3>${player.name}</h3><p>çœŸèº«: ${getRoleDisplayName(player.initialRole)}</p><p>ç¾èº«: ${getRoleDisplayName(player.currentRole)}</p>`;
                finalRolesDiv.appendChild(cardDiv);
            });
            state.centerCards.forEach(card => {
                const cardDiv = document.createElement('div');
                cardDiv.classList.add('center-card');
                cardDiv.innerHTML = `<h3>æª¯é¢ç‰Œ ${card.id.replace('c','')}</h3><p>${getRoleDisplayName(card.role)}</p>`;
                finalRolesDiv.appendChild(cardDiv);
            });
             showSection('results-section'); // Directly show results when all roles are revealed
        }

        function showSection(sectionId) {
            document.querySelectorAll('.game-section, .night-phase').forEach(section => {
                section.style.display = 'none';
            });
            document.getElementById(sectionId).style.display = 'block';
            state.currentPhase = sectionId.replace('-section', '').replace('-phase', ''); // Update current phase
        }

        // Game Logic Functions

        function loadRecommendedConfig(count) {
            const configRoles = RECOMMENDED_CONFIGS[count];
            if (configRoles) {
                state.rolesInPlay = [...configRoles]; // Deep copy
            } else {
                // If no recommended config, use default set of ROLES_ARRAY and trim/add
                let allPossibleRoles = [...ROLES_ARRAY];
                while (allPossibleRoles.length < count + 3) {
                    allPossibleRoles.push('æ‘æ°‘'); // Add genericæ‘æ°‘ if not enough roles
                }
                state.rolesInPlay = allPossibleRoles.slice(0, count + 3);
            }
            displayDrawnCards();
        }

        function startGame() {
            state.players = [];
            for (let i = 0; i < playerCount; i++) {
                const playerNameInput = document.getElementById(`p${i + 1}name`);
                const playerName = playerNameInput && playerNameInput.value ? playerNameInput.value : `ç©å®¶${i + 1}`;
                state.players.push({
                    id: `p${i + 1}`,
                    name: playerName,
                    initialRole: '',
                    currentRole: '',
                    hasViewed: false,
                    voteFor: null
                });
            }

            // Ensure rolesInPlay has N+3 cards
            if (state.rolesInPlay.length !== playerCount + 3) {
                 const currentRoles = [...document.querySelectorAll('#drawn-cards .role-card h3')].map(h3 => h3.textContent);
                 if (currentRoles.length === playerCount + 3) {
                     state.rolesInPlay = currentRoles; // Use manually picked roles if config not loaded
                 } else { // Fallback, use the default ROLES_ARRAY if not explicitly chosen
                    let tempRoles = [...ROLES_ARRAY];
                    while (tempRoles.length < playerCount + 3) {
                        tempRoles.push('æ‘æ°‘');
                    }
                    state.rolesInPlay = tempRoles.slice(0, playerCount + 3);
                }
            }


            const shuffledRoles = shuffleArray([...state.rolesInPlay]);
            state.centerCards = [];

            // Distribute player roles
            for (let i = 0; i < playerCount; i++) {
                state.players[i].initialRole = shuffledRoles.shift();
                state.players[i].currentRole = state.players[i].initialRole;
            }

            // Distribute center cards
            for (let i = 0; i < 3; i++) {
                state.centerCards.push({ id: `c${i + 1}`, role: shuffledRoles.shift() });
            }
             console.log("Game started! Players:", state.players, "Center cards:", state.centerCards);
            showSection('private-view-section');
            displayPlayerViewCards();
        }

        function viewPlayerCard(playerId) {
            const player = state.players.find(p => p.id === playerId);
            if (!player) return;

            const cardElement = document.querySelector(`.player-card[data-player-id="${playerId}"]`);
            if (player.hasViewed) {
                cardElement.querySelector('p').textContent = `èº«ä»½: ???`;
                cardElement.querySelector('.view-card-btn').textContent = 'ç‡ç‰Œ';
                player.hasViewed = false;
            } else {
                cardElement.querySelector('p').textContent = `èº«ä»½: ${getRoleDisplayName(player.currentRole)}`;
                cardElement.querySelector('.view-card-btn').textContent = 'æ”¶åŸ‹';
                player.hasViewed = true;
                setTimeout(() => {
                    if (player.hasViewed) { // Check if it's still viewed after timeout
                        cardElement.querySelector('p').textContent = `èº«ä»½: ???`;
                        cardElement.querySelector('.view-card-btn').textContent = 'ç‡ç‰Œ';
                        player.hasViewed = false;
                    }
                }, 5000); // Hide after 5 seconds
            }
        }
        
        // Night Phase Logic
        let activeSkillRole = null;
        let skillTargetingData = {}; // To store temporary choices for a skill

        function activateNightSkill(role) {
            activeSkillRole = role;
            skillTargetingData = {}; // Reset targeting data

            document.querySelectorAll('#night-actions .game-button').forEach(btn => btn.disabled = true);
            document.getElementById('skill-action-area').style.display = 'block';
            document.getElementById('skill-description').textContent = `${role}: ${SKILLS[role]}`;
            const skillTargetsDiv = document.getElementById('skill-targets');
            skillTargetsDiv.innerHTML = '';
            
            // Skill specific UI population
            switch (role) {
                case 'ç‹¼äºº':
                    handleWerewolfSkill(skillTargetsDiv);
                    break;
                case 'é è¨€å®¶':
                    handleSeerSkill(skillTargetsDiv);
                    break;
                case 'å¼·ç›œ':
                    handleRobberSkill(skillTargetsDiv);
                    break;
                case 'æ—è›‹é¬¼':
                    handleTroublemakerSkill(skillTargetsDiv);
                    break;
                case 'é…’é¬¼':
                    handleDrunkSkill(skillTargetsDiv);
                    break;
                case 'å¤±çœ è€…':
                    handleInsomniacSkill(skillTargetsDiv);
                    break;
                case 'åŒ–èº«å¹½éˆ':
                     handleDoppelgangerSkill(skillTargetsDiv);
                     break;
                case 'çˆªç‰™':
                     handleMinionSkill(skillTargetsDiv);
                     break;
                case 'å®ˆå¤œäºº':
                     handleMasonSkill(skillTargetsDiv);
                     break;
                default:
                    // For roles with no active night skill, just confirm/skip
                    document.getElementById('confirm-skill-button').style.display = 'block';
                    document.getElementById('skip-skill-button').style.display = 'block';
                    skillTargetsDiv.innerHTML = `<p>å‘¢å€‹è§’è‰²å†‡æŒ‡å®šè¡Œå‹•ï¼Œå¯ä»¥è·³éã€‚</p>`;
                    break;
            }
        }

        function handleDoppelgangerSkill(skillTargetsDiv) {
            const selectTarget = createPlayerSelect('doppelganger-target', 'è¤‡è£½é‚Šå€‹èº«ä»½:');
            skillTargetsDiv.appendChild(selectTarget);
            document.getElementById('confirm-skill-button').style.display = 'block';
            document.getElementById('skip-skill-button').style.display = 'block';
        }

        function handleWerewolfSkill(skillTargetsDiv) {
            const werewolves = state.players.filter(p => p.currentRole === 'ç‹¼äºº');
            const centerCardsDisplay = document.createElement('div');
            centerCardsDisplay.innerHTML = `<p style="font-weight:bold; margin-top:10px;">æ¡Œé¢ç‰Œ:</p>`;
            state.centerCards.forEach(card => {
                const cardDiv = document.createElement('span');
                cardDiv.classList.add('center-card');
                cardDiv.style.cursor = 'pointer';
                cardDiv.textContent = `æª¯é¢ç‰Œ ${card.id.replace('c','')}`;
                cardDiv.dataset.cardId = card.id;
                cardDiv.addEventListener('click', () => {
                    skillTargetingData.centerCard = card.id;
                    cardDiv.style.backgroundColor = 'var(--accent-dark-green)';
                    document.querySelectorAll('.center-card').forEach(c => {
                        if (c.dataset.cardId !== card.id) c.style.backgroundColor = '';
                    });
                });
                centerCardsDisplay.appendChild(cardDiv);
            });
            skillTargetsDiv.appendChild(centerCardsDisplay);

            if (werewolves.length === 1) { // Lone wolf
                skillTargetsDiv.innerHTML = `<p>ä½ ä¿‚ç¨ç‹¼! å¯ä»¥ç‡ä¸€å¼µæ¡Œé¢ç‰Œã€‚</p>`;
                skillTargetsDiv.appendChild(centerCardsDisplay);
                document.getElementById('confirm-skill-button').style.display = 'block';
                document.getElementById('skip-skill-button').style.display = 'block';
            } else if (werewolves.length > 1) { // Multiple werewolves
                skillTargetsDiv.innerHTML = `<p>ä½ å“‹ä¿‚ç‹¼äººéšŠå‹! ${werewolves.map(w => w.name).join(', ')}</p><p>å””ä½¿è¡Œå‹•ï¼Œè·³éå°±å¾—ã€‚</p>`;
                document.getElementById('confirm-skill-button').style.display = 'none'; // No active choice needed
                document.getElementById('skip-skill-button').style.display = 'block';
            } else { // No werewolves (shouldn't happen with current config logic but for robustness)
                skillTargetsDiv.innerHTML = `<p>éŠæˆ²å†‡ç‹¼äººï¼Œå””ä½¿è¡Œå‹•ã€‚</p>`;
                document.getElementById('confirm-skill-button').style.display = 'none';
                document.getElementById('skip-skill-button').style.display = 'block';
            }
        }

        function handleMinionSkill(skillTargetsDiv) {
            const werewolves = state.players.filter(p => p.currentRole === 'ç‹¼äºº');
            if (werewolves.length > 0) {
                skillTargetsDiv.innerHTML = `<p>ç‹¼äººä½ç½®: ${werewolves.map(w => w.name).join(', ')}</p><p>ç„¡éœ€è¦è¡Œå‹•ï¼Œè·³éå°±å¾—ã€‚</p>`;
                document.getElementById('confirm-skill-button').style.display = 'none';
                document.getElementById('skip-skill-button').style.display = 'block';
            } else {
                skillTargetsDiv.innerHTML = `<p>å†‡ç‹¼äººï¼Œå¦‚æœäººç‹¼æ­»å°±æ‘æ°‘è´ï¼</p><p>ç„¡éœ€è¦è¡Œå‹•ï¼Œè·³éå°±å¾—ã€‚</p>`;
                document.getElementById('confirm-skill-button').style.display = 'none';
                document.getElementById('skip-skill-button').style.display = 'block';
            }
        }
        
        function handleMasonSkill(skillTargetsDiv) {
            const masons = state.players.filter(p => p.currentRole === 'å®ˆå¤œäºº');
            if (masons.length > 1) {
                skillTargetsDiv.innerHTML = `<p>ä½ å“‹ä¿‚å®ˆå¤œäººéšŠå‹: ${masons.map(m => m.name).join(', ')}</p><p>ç„¡éœ€è¦è¡Œå‹•ï¼Œè·³éå°±å¾—ã€‚</p>`;
            } else {
                skillTargetsDiv.innerHTML = `<p>ä½ ä¿‚å­¤ç¨å˜…å®ˆå¤œäººã€‚</p><p>ç„¡éœ€è¦è¡Œå‹•ï¼Œè·³éå°±å¾—ã€‚</p>`;
            }
            document.getElementById('confirm-skill-button').style.display = 'none';
            document.getElementById('skip-skill-button').style.display = 'block';
        }

        function handleSeerSkill(skillTargetsDiv) {
            const selectPlayer = createPlayerSelect('seer-player-target', 'æŸ¥ä¸€å€‹ç©å®¶èº«ä»½:');
            const selectCenter1 = createCenterCardSelect('seer-center-target1', 'ç‡ä¸€å¼µæ¡Œé¢ç‰Œ:');
            const selectCenter2 = createCenterCardSelect('seer-center-target2');
            
            selectPlayer.style.display = 'inline-block';
            selectCenter1.style.display = 'inline-block';
            selectCenter2.style.display = 'inline-block';

            skillTargetsDiv.appendChild(selectPlayer);
            skillTargetsDiv.appendChild(selectCenter1);
            skillTargetsDiv.appendChild(selectCenter2);

            document.getElementById('confirm-skill-button').style.display = 'block';
            document.getElementById('skip-skill-button').style.display = 'block';
        }

        function handleRobberSkill(skillTargetsDiv) {
            const selectTarget = createPlayerSelect('robber-target', 'æ›é‚Šå€‹èº«ä»½:');
            skillTargetsDiv.appendChild(selectTarget);
            document.getElementById('confirm-skill-button').style.display = 'block';
            document.getElementById('skip-skill-button').style.display = 'block';
        }

        function handleTroublemakerSkill(skillTargetsDiv) {
            const selectTarget1 = createPlayerSelect('troublemaker-target1', 'ç©å®¶1:');
            const selectTarget2 = createPlayerSelect('troublemaker-target2', 'ç©å®¶2:');
            skillTargetsDiv.appendChild(selectTarget1);
            skillTargetsDiv.appendChild(selectTarget2);
            document.getElementById('confirm-skill-button').style.display = 'block';
            document.getElementById('skip-skill-button').style.display = 'block';
        }

        function handleDrunkSkill(skillTargetsDiv) {
            const selectTarget = createCenterCardSelect('drunk-target', 'æ›é‚Šå¼µæ¡Œé¢ç‰Œ:');
            skillTargetsDiv.appendChild(selectTarget);
            document.getElementById('confirm-skill-button').style.display = 'block';
            document.getElementById('skip-skill-button').style.display = 'block';
        }

        function handleInsomniacSkill(skillTargetsDiv) {
            // Insomniac essentially just views their own card at the end of the night
            // No direct action/selection needed here beyond 'confirm' to acknowledge
            skillTargetsDiv.innerHTML = `<p>é†’å’—å˜…ä½ ï¼Œå¯ä»¥ç¢ºèªä½ å˜…æœ€çµ‚èº«ä»½ã€‚</p>`;
            document.getElementById('confirm-skill-button').style.display = 'block';
            document.getElementById('skip-skill-button').style.display = 'block';
        }

        function createPlayerSelect(id, labelText) {
            const div = document.createElement('div');
            div.style.marginBottom = '10px';
            const label = document.createElement('label');
            label.setAttribute('for', id);
            label.textContent = labelText;
            const select = document.createElement('select');
            select.id = id;
            select.name = id;
            state.players.forEach(player => {
                const option = document.createElement('option');
                option.value = player.id;
                option.textContent = player.name;
                select.appendChild(option);
            });
            div.appendChild(label);
            div.appendChild(select);
            return div;
        }

        function createCenterCardSelect(id, labelText = 'é¸æ¡Œé¢ç‰Œ:') {
            const div = document.createElement('div');
            div.style.marginBottom = '10px';
            const label = document.createElement('label');
            label.setAttribute('for', id);
            label.textContent = labelText;
            const select = document.createElement('select');
            select.id = id;
            select.name = id;
            state.centerCards.forEach(card => {
                const option = document.createElement('option');
                option.value = card.id;
                option.textContent = `æ¡Œé¢ç‰Œ ${card.id.replace('c','')}`;
                select.appendChild(option);
            });
            div.appendChild(label);
            div.appendChild(select);
            return div;
        }

        function confirmNightSkill() {
            const currentPlayer = state.players[state.activePlayerIndex]; // The player whose turn it actually is to resolve the skill

            const skillActionArea = document.getElementById('skill-action-area');
            const nightActionsButtons = document.querySelectorAll('#night-actions .game-button');
            const currentSkillButton = document.querySelector(`#night-actions button[data-role="${activeSkillRole}"]`);

            switch (activeSkillRole) {
                case 'åŒ–èº«å¹½éˆ':
                    const doppelgangerTargetId = document.getElementById('doppelganger-target').value;
                    const doppelgangerTargetPlayer = state.players.find(p => p.id === doppelgangerTargetId);
                    if (doppelgangerTargetPlayer) {
                        // The Doppelganger becomes the role they chose, and then performs *that* role's action
                        // For simplicity in this initial version, we will just record the target.
                        // The actual action resolution might be too complex for a one-shot simulation.
                        // So, for now, doppelganger just chooses identity, not performs role.
                        // The prompt says "è¤‡è£½èº«ä»½+å‹æ¢ä»¶", so this change of role is important.
                        const originalRole = currentPlayer.currentRole;
                        currentPlayer.currentRole = doppelgangerTargetPlayer.currentRole;
                        state.messages.push(`${currentPlayer.name} (åŒ–èº«å¹½éˆ) è®Šæˆå’— ${getRoleDisplayName(currentPlayer.currentRole)}ã€‚`);
                        console.log(`${currentPlayer.name} (Doppelganger) became ${currentPlayer.currentRole}.`);
                        // A prompt asks "æ¨¡æ“¬æŠ€èƒ½(é¸äºº/è‡ªå‹•, æ›´æ–°ç‹€æ…‹)" - this means the state of roles must reflect this change.
                        // However, the DOppelganger's new role's action happens 'now' as the doppelganger.
                        // This implies I need to re-activate a *new* skill for the doppelganger based on the chosen role.
                        // This makes the night phase order dynamic, which is more complex.
                        // For a "smallest workable 6-player" version, I will only have the doppelganger record the target,
                        // and their "final" role will be based on that at the reveal.
                        // Re-reading prompt: "é¸1ç©å®¶è¤‡è£½èº«ä»½+å‹æ¢ä»¶" - it means only copy role and win condition, not perform action.
                        // So the change is internal state only.
                    }
                    break;
                case 'ç‹¼äºº':
                    if (skillTargetingData.centerCard) {
                        const targetCard = state.centerCards.find(c => c.id === skillTargetingData.centerCard);
                        if (targetCard) {
                            state.messages.push(`${currentPlayer.name} (ç¨ç‹¼) ç‡å’—å¼µæ¡Œé¢ç‰Œ: ${getRoleDisplayName(targetCard.role)}ã€‚`);
                            console.log(`Lone Wolf ${currentPlayer.name} viewed center card ${targetCard.id}: ${targetCard.role}`);
                        }
                    }
                    break;

                case 'é è¨€å®¶':
                    const seerPlayerTargetId = document.getElementById('seer-player-target').value;
                    const seerCenterTarget1Id = document.getElementById('seer-center-target1').value;
                    const seerCenterTarget2Id = document.getElementById('seer-center-target2').value;

                    const seerTargetPlayer = state.players.find(p => p.id === seerPlayerTargetId);
                    const seerTargetCenter1 = state.centerCards.find(c => c.id === seerCenterTarget1Id);
                    const seerTargetCenter2 = state.centerCards.find(c => c.id === seerCenterTarget2Id);

                    let message = `${currentPlayer.name} (é è¨€å®¶) æŸ¥`;
                    if (seerTargetPlayer) {
                        state.messages.push(`${message}å’— ${seerTargetPlayer.name} å˜…èº«ä»½: ${getRoleDisplayName(seerTargetPlayer.currentRole)}ã€‚`);
                        console.log(`Seer ${currentPlayer.name} viewed ${seerTargetPlayer.name}: ${seerTargetPlayer.currentRole}`);
                    } else if (seerTargetCenter1 && seerTargetCenter2) {
                        state.messages.push(`${message}å’—å…©å¼µæ¡Œé¢ç‰Œ: ${getRoleDisplayName(seerTargetCenter1.role)} åŒ ${getRoleDisplayName(seerTargetCenter2.role)}ã€‚`);
                        console.log(`Seer ${currentPlayer.name} viewed center cards ${seerTargetCenter1.id}: ${seerTargetCenter1.role} and ${seerTargetCenter2.id}: ${seerTargetCenter2.role}`);
                    } else {
                         state.messages.push(`${message}å””åˆ°å˜¢ï¼Œå¯èƒ½ä¿‚å†‡åšé¸æ“‡ã€‚`);
                    }
                    break;

                case 'å¼·ç›œ':
                    const robberTargetId = document.getElementById('robber-target').value;
                    const robberTargetPlayer = state.players.find(p => p.id === robberTargetId);
                    if (robberTargetPlayer) {
                        const robberOriginalRole = currentPlayer.currentRole;
                        currentPlayer.currentRole = robberTargetPlayer.currentRole;
                        robberTargetPlayer.currentRole = robberOriginalRole;
                        state.messages.push(`${currentPlayer.name} (å¼·ç›œ) åŒ ${robberTargetPlayer.name} äº¤æ›å’—èº«ä»½ã€‚è€Œå®¶ ${currentPlayer.name} ä¿‚ ${getRoleDisplayName(currentPlayer.currentRole)}ï¼Œ${robberTargetPlayer.name} ä¿‚ ${getRoleDisplayName(robberTargetPlayer.currentRole)}ã€‚`);
                        console.log(`Robber ${currentPlayer.name} swapped roles with ${robberTargetPlayer.name}. ${currentPlayer.name} is now ${currentPlayer.currentRole}, ${robberTargetPlayer.name} is now ${robberTargetPlayer.currentRole}.`);
                     }
                    break;

                case 'æ—è›‹é¬¼':
                    const troublemakerTarget1Id = document.getElementById('troublemaker-target1').value;
                    const troublemakerTarget2Id = document.getElementById('troublemaker-target2').value;
                    const troublemakerTargetPlayer1 = state.players.find(p => p.id === troublemakerTarget1Id);
                    const troublemakerTargetPlayer2 = state.players.find(p => p.id === troublemakerTarget2Id);
                    if (troublemakerTargetPlayer1 && troublemakerTargetPlayer2 && troublemakerTargetPlayer1.id !== troublemakerTargetPlayer2.id) {
                        const role1 = troublemakerTargetPlayer1.currentRole;
                        troublemakerTargetPlayer1.currentRole = troublemakerTargetPlayer2.currentRole;
                        troublemakerTargetPlayer2.currentRole = role1;
                        state.messages.push(`${currentPlayer.name} (æ—è›‹é¬¼) å°‡ ${troublemakerTargetPlayer1.name} åŒ ${troublemakerTargetPlayer2.name} å˜…èº«ä»½äº¤æ›å’—ã€‚`);
                        console.log(`Troublemaker ${currentPlayer.name} swapped roles of ${troublemakerTargetPlayer1.name} and ${troublemakerTargetPlayer2.name}.`);
                    } else {
                        state.messages.push(`${currentPlayer.name} (æ—è›‹é¬¼) å†‡æ›åˆ°èº«ä»½ (å¯èƒ½å†‡é¸å¤ å…©å€‹å””åŒå˜…ç©å®¶)ã€‚`);
                        console.log(`Troublemaker target invalid or same player selected.`);
                    }
                    break;

                case 'é…’é¬¼':
                    const drunkTargetCardId = document.getElementById('drunk-target').value;
                    const drunkTargetCard = state.centerCards.find(c => c.id === drunkTargetCardId);
                    if (drunkTargetCard) {
                        const playerOriginalRole = currentPlayer.currentRole;
                        currentPlayer.currentRole = drunkTargetCard.role;
                        drunkTargetCard.role = playerOriginalRole; // Player's original card goes to center
                        state.messages.push(`${currentPlayer.name} (é…’é¬¼) ç›²æŠ½å’—å¼µæ¡Œé¢ç‰Œ ${drunkTargetCard.id.replace('c','')} äº¤æ›å’—èº«ä»½ã€‚è€Œå®¶ ${currentPlayer.name} ä¿‚ ${getRoleDisplayName(currentPlayer.currentRole)}ã€‚`);
                        console.log(`Drunk ${currentPlayer.name} blindly swapped with center card ${drunkTargetCard.id}. ${currentPlayer.name} is now ${currentPlayer.currentRole}.`);
                    }
                    break;

                case 'å¤±çœ è€…':
                    // Insomniac just re-views their own card at the end of night actions
                    state.messages.push(`${currentPlayer.name} (å¤±çœ è€…) é‡ç‡å’—è‡ªå·±å˜…èº«ä»½: ${getRoleDisplayName(currentPlayer.currentRole)}ã€‚`);
                    console.log(`Insomniac ${currentPlayer.name} re-viewed their role: ${currentPlayer.currentRole}`);
                    break;
                case 'çˆªç‰™': // Minion and Mason have no active choice for player to make
                case 'å®ˆå¤œäºº':
                    state.messages.push(`${currentPlayer.name} (${activeSkillRole}) å†‡æŒ‡å®šè¡Œå‹•ã€‚`);
                     console.log(`${activeSkillRole} has no active skill action.`);
                    break;
                default:
                    state.messages.push(`${currentPlayer.name} å†‡åŸ·è¡Œä»»ä½•è¡Œå‹•ã€‚`);
                    console.log(`No specific action for role ${activeSkillRole}.`);
                    break;
            }

            // After confirming skill, deactivate UI and prepare for next
            skillActionArea.style.display = 'none';
            nightActionsButtons.forEach(btn => btn.disabled = false);
            if (currentSkillButton) {
                currentSkillButton.disabled = true; // Disable the button for the just-completed role
                currentSkillButton.classList.add('executed-skill'); // Optional: visual cue
            }

            // Check if all night actions are done
            const allActionsCompleted = state.nightOrder.every(role => {
                const button = document.querySelector(`#night-actions button[data-role="${role}"]`);
                return !button || button.disabled; // If button exists, it must be disabled to be "completed"
            });

            if (allActionsCompleted) {
                document.getElementById('day-phase-button').style.display = 'block';
            }
        }

        function skipNightSkill() {
            const skillActionArea = document.getElementById('skill-action-area');
            const nightActionsButtons = document.querySelectorAll('#night-actions .game-button');
            const currentSkillButton = document.querySelector(`#night-actions button[data-role="${activeSkillRole}"]`);

            // Log skipped action if needed
            state.messages.push(`${state.players[state.activePlayerIndex].name} (${activeSkillRole}) è·³éå’—ä»Šæ™šå˜…è¡Œå‹•ã€‚`);
            console.log(`${activeSkillRole} skipped action.`);

            skillActionArea.style.display = 'none';
            nightActionsButtons.forEach(btn => btn.disabled = false);
            if (currentSkillButton) {
                currentSkillButton.disabled = true;
                currentSkillButton.classList.add('skipped-skill');
            }
            const allActionsCompleted = state.nightOrder.every(role => {
                const button = document.querySelector(`#night-actions button[data-role="${role}"]`);
                return !button || button.disabled;
            });

            if (allActionsCompleted) {
                document.getElementById('day-phase-button').style.display = 'block';
            }
        }

        function castVote() {
            const voteTargetSelect = document.getElementById('vote-target');
            const playerVoting = state.players[state.activePlayerIndex]; // The player who is currently casting their vote
            const targetId = voteTargetSelect.value;
            playerVoting.voteFor = targetId;

            state.messages.push(`${playerVoting.name} æŠ•å’— ${state.players.find(p => p.id === targetId).name} ä¸€ç¥¨ã€‚`);
            console.log(`${playerVoting.name} voted for ${state.players.find(p => p.id === targetId).name}.`);

            state.activePlayerIndex++;
            if (state.activePlayerIndex < state.players.length) {
                document.getElementById('cast-vote-button').textContent = `æŠ•ç¥¨ (${state.players[state.activePlayerIndex].name})`;
                 voteTargetSelect.value = state.players[state.activePlayerIndex].id; // Pre-select current player to vote for themselves (default)
            } else {
                document.getElementById('cast-vote-button').disabled = true;
                document.getElementById('show-results-button').style.display = 'block';
                document.getElementById('final-votes').style.display = 'block';
                calculateAndDisplayVotes();
            }
        }

        function calculateAndDisplayVotes() {
            const voteCounts = {}; // { playerId: count }
            state.players.forEach(player => {
                if (player.voteFor) {
                    voteCounts[player.voteFor] = (voteCounts[player.voteFor] || 0) + 1;
                }
            });
            state.votes = voteCounts; // Store for results calculation

            const voteCountsUl = document.getElementById('vote-counts');
            voteCountsUl.innerHTML = '';
            for (const playerId in voteCounts) {
                const li = document.createElement('li');
                li.textContent = `${state.players.find(p => p.id === playerId).name}: ${voteCounts[playerId]} ç¥¨`;
                voteCountsUl.appendChild(li);
            }
        }

        function showResults() {
            showSection('results-section');
            let maxVotes = 0;
            let playersWithMaxVotes = [];

            for (const playerId in state.votes) {
                if (state.votes[playerId] > maxVotes) {
                    maxVotes = state.votes[playerId];
                    playersWithMaxVotes = [playerId];
                } else if (state.votes[playerId] === maxVotes) {
                    playersWithMaxVotes.push(playerId);
                }
            }

            // Determine who dies
            if (playersWithMaxVotes.length === 0) {
                 state.dead = []; // No votes, no one dies.
            } else if (playersWithMaxVotes.length === 1) {
                state.dead.push(state.players.find(p => p.id === playersWithMaxVotes[0]));
            } else {
                // Tie: no one dies if there's no clear majority, usually.
                // One Night rules: If there's a tie for most votes, *everyone* who tied dies.
                playersWithMaxVotes.forEach(playerId => {
                    state.dead.push(state.players.find(p => p.id === playerId));
                });
            }
            
            // Hunter Effect (if Hunter is among those who died and game has a hunter)
            const hunterRole = state.players.find(p => p.initialRole === 'çµäºº' || p.currentRole === 'çµäºº'); // Hunter's final role or initial role can be hunter
            let hunterTriggeredKill = false;
            if (hunterRole && state.dead.some(d => d.id === hunterRole.id)) {
                // Hunter dies, takes the player with most votes *from previous round of voting* (or if tied, no one)
                // In One Night, if Hunter dies they shoot the player they voted for.
                const hunterVotedForId = state.players.find(p => p.id === hunterRole.id)?.voteFor;
                if (hunterVotedForId && !state.dead.some(d => d.id === hunterVotedForId)) { // If hunter voted for someone who isn't already dead
                    const targetPlayer = state.players.find(p => p.id === hunterVotedForId);
                    if (targetPlayer) {
                        state.dead.push(targetPlayer);
                        hunterTriggeredKill = true;
                        state.messages.push(`${hunterRole.name} (çµäºº) æ­»å’—ï¼Œä½¢å¸¶èµ°å’—ä½¢æŠ•å˜… ${targetPlayer.name}ï¼`);
                        console.log(`Hunter ${hunterRole.name} died and took down ${targetPlayer.name}.`);
                    }
                }
            }


            const finalRolesDiv = document.getElementById('final-roles');
            finalRolesDiv.innerHTML = '';
            state.players.forEach(player => {
                const isDead = state.dead.some(d => d.id === player.id);
                const cardDiv = document.createElement('div');
                cardDiv.classList.add('player-card');
                if (isDead) {
                    cardDiv.style.backgroundColor = 'darkred';
                    cardDiv.style.color = 'white';
                }
                cardDiv.innerHTML = `<h3>${player.name}</h3><p>çœŸèº«: ${getRoleDisplayName(player.initialRole)}</p><p>æœ€çµ‚èº«ä»½: ${getRoleDisplayName(player.currentRole)} ${isDead ? '(å·²æ­»)' : ''}</p>`;
                finalRolesDiv.appendChild(cardDiv);
            });
            state.centerCards.forEach(card => {
                const cardDiv = document.createElement('div');
                cardDiv.classList.add('center-card');
                cardDiv.innerHTML = `<h3>æª¯é¢ç‰Œ ${card.id.replace('c','')}</h3><p>${getRoleDisplayName(card.role)}</p>`;
                finalRolesDiv.appendChild(cardDiv);
            });

            // Determine Winner
            let resultMessage = "å†‡è´å®¶?";
            let werewolvesAlive = state.players.filter(p => p.currentRole === 'ç‹¼äºº' && !state.dead.some(d => d.id === p.id)).length > 0;
            let villagersAlive = state.players.filter(p => !['ç‹¼äºº', 'çˆªç‰™'].includes(p.currentRole) && !state.dead.some(d => d.id === p.id)).length > 0;
            let minionAlive = state.players.some(p => p.currentRole === 'çˆªç‰™' && !state.dead.some(d => d.id === p.id));
            let tannerAlive = state.players.some(p => p.currentRole === 'çš®åŒ ' && !state.dead.some(d => d.id === p.id));

            // Win condition for Tanner: If Tanner is the *only* one who dies
            let tannerWins = false;
            let deadTanners = state.dead.filter(p => p.currentRole === 'çš®åŒ ');
            if (deadTanners.length > 0 && state.dead.length === deadTanners.length) {
                resultMessage = "çš®åŒ è´æ™’! ä½¢ä¿‚å”¯ä¸€ä¸€å€‹æ­»å˜…äºº!";
                tannerWins = true;
            }

            if (!tannerWins) {
                if (!werewolvesAlive) { // No werewolves left alive
                    // Check if there were any werewolves OR minions in play to begin with
                    const initialWerewolvesInPlay = state.rolesInPlay.filter(r => r === 'ç‹¼äºº').length > 0;
                    const initialMinionsInPlay = state.rolesInPlay.filter(r => r === 'çˆªç‰™').length > 0;

                    if (!initialWerewolvesInPlay && !initialMinionsInPlay) {
                        // No werewolves or minions in play, so villagers always win by default if no one dies
                        resultMessage = "éŠæˆ²å†‡ç‹¼äººï¼Œæ‘æ°‘å€‘è´å’—!";
                    } else if (!state.dead.length) {
                        // Werewolves and/or minions were in play, but no one died. Villagers lose unless no wolves were in play.
                         resultMessage = "å†‡äººæ­»ï¼Œç‹¼äººè´æ™’!"; // If no one dies, wolves win generally
                    } else if (!initialWerewolvesInPlay && state.dead.length > 0) {
                         // No werewolves in play, someone died, villagers still win
                         resultMessage = "å†‡ç‹¼äººï¼Œæ‘æ°‘å€‘è´å’—!";
                    } else { // Werewolves were in play and all died
                        resultMessage = "æ‰€æœ‰ç‹¼äººéƒ½æ­»æ™’ï¼Œæ‘æ°‘å€‘è´å’—!";
                    }
                } else { // Werewolves are still alive
                    // If a Minion is alive and a werewolf is alive, and no one died, werewolves/minions win because no one died.
                    const anyWolfOrMinionDied = state.dead.some(p => ['ç‹¼äºº', 'çˆªç‰™'].includes(p.currentRole));
                    
                    if (state.dead.length === 0) { // No one died, and wolves are alive
                        resultMessage = "å†‡äººæ­»ï¼Œç‹¼äººè´æ™’!";
                    } else if (anyWolfOrMinionDied && !werewolvesAlive) { // A wolf died, and now no wolves are alive (handled above)
                         resultMessage = "æ‰€æœ‰ç‹¼äººéƒ½æ­»æ™’ï¼Œæ‘æ°‘å€‘è´å’—!";
                    } else if (!anyWolfOrMinionDied && werewolvesAlive) { // Only villagers or tanners died, wolves still alive
                        resultMessage = "ç‹¼äººä»ç„¶å¥åœ¨ï¼Œç‹¼äººè´æ™’!";
                    } else { // Some other complex scenario
                         resultMessage = "éŠæˆ²çµæœä¸æ˜ã€‚";
                    }
                }

                // Minion specific win condition: If Minion is alive and all Werewolves died, Minion wins with Villagers.
                // This rule is tricky. "ç„¡ç‹¼æ™‚ä»»ä¸€æ­»=å‹" from prompt seems to imply standalone win if no wolves at all.
                // If there are no actual Werewolves in the game (either through initial roles or swaps), AND if *anyone* dies, then the Minion wins.
                // If there are actual Werewolves and they all die, Minion wins with Villagers.
                const wasMinionInPlay = state.rolesInPlay.includes('çˆªç‰™');
                if (wasMinionInPlay && minionAlive) {
                    const actualWerewolvesInGame = state.players.filter(p => p.currentRole === 'ç‹¼äºº').length > 0 || state.centerCards.filter(c => c.role === 'ç‹¼äºº').length > 0;
                    if (!werewolvesAlive) { // All werewolves died
                         resultMessage = "æ‰€æœ‰ç‹¼äººéƒ½æ­»æ™’ï¼Œçˆªç‰™åŒæ‘æ°‘è´å’—!";
                    } else if (!actualWerewolvesInGame && state.dead.length > 0) { // No actual wolves in game AND someone died
                        resultMessage = "éŠæˆ²å†‡ç‹¼äººï¼Œæœ‰äººæ­»ï¼Œçˆªç‰™ç¨è´!";
                    }
                }
            }


            document.getElementById('results-banner').textContent = resultMessage;
        }

        function restartGame() {
            // Reset state
            state = {
                players: [],
                centerCards: [],
                rolesInPlay: [],
                nightOrder: ['åŒ–èº«å¹½éˆ', 'ç‹¼äºº', 'çˆªç‰™', 'å®ˆå¤œäºº', 'é è¨€å®¶', 'å¼·ç›œ', 'æ—è›‹é¬¼', 'é…’é¬¼', 'å¤±çœ è€…'],
                currentPhase: 'setup',
                activePlayerIndex: 0,
                activeNightSkillIndex: 0,
                votes: {},
                dead: [],
                messages: []
            };
            playerCount = 6; // Reset to default

            // Reset UI
            document.getElementById('player-count').textContent = playerCount;
            document.querySelectorAll('.player-count-selector button').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.player-count-selector button[data-count="6"]`).classList.add('active');
            document.querySelectorAll('.config-button').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.config-button[data-config="6"]`).classList.add('active');


            document.getElementById('drawn-cards').innerHTML = '';
            document.getElementById('player-view-cards').innerHTML = '';
            document.getElementById('night-actions').innerHTML = '';
            document.getElementById('skill-action-area').style.display = 'none';
            document.getElementById('day-phase-button').style.display = 'none';
            document.getElementById('discussion-area').querySelector('textarea').value = '';
            document.getElementById('vote-target').innerHTML = '';
            document.getElementById('cast-vote-button').textContent = `æŠ•ç¥¨ (ç©å®¶1)`;
            document.getElementById('cast-vote-button').disabled = false;
            document.getElementById('show-results-button').style.display = 'none';
            document.getElementById('final-votes').style.display = 'none';
            document.getElementById('vote-counts').innerHTML = '';
            document.getElementById('final-roles').innerHTML = '';
            document.getElementById('results-banner').textContent = 'å‹è² åˆ¤æ–·çµæœ';

            loadRecommendedConfig(playerCount); // Load default 6-player config initially

            showSection('setup-section');
        }

        // Event Listeners
        document.addEventListener('DOMContentLoaded', () => {
            renderRoleSkills(); // Populate role summary
            updatePlayerCount(playerCount); // Initialize player count and recommended config
            loadRecommendedConfig(playerCount); // Manually load for default 6 players too.

            // Event listener for player count select box
            document.getElementById('playerCount').addEventListener('change', (event) => {
                updatePlayerCount(parseInt(event.target.value));
            });

            // Event listener for recommended config button
            document.getElementById('recommended-config-button').addEventListener('click', () => {
                const count = parseInt(document.getElementById('playerCount').value);
                loadRecommendedConfig(count);
                 updateGameButtons();
            });

            // Event listener for dealing cards
            document.getElementById('deal-cards-button').addEventListener('click', () => {
                dealCards();
                document.getElementById('shuffle-distribute-button').disabled = false;
            });

            // Event listener for shuffling and distributing cards
            document.getElementById('shuffle-distribute-button').addEventListener('click', () => {
                startGame(); // Distributes to players and center
                showSection('private-view-section');
                updateGameButtons();

            });

            // Event listener for revealing all cards (debug/end game)
            document.getElementById('reveal-all-button').addEventListener('click', () => {
                revealAllRoles();
                // You might want to automatically show results section after revealing all
                showResults();
            });

            // Event listener for specific 'view card' buttons when clicked per player in private view
            document.getElementById('player-view-cards').addEventListener('click', (event) => {
                if (event.target.classList.contains('view-card-btn')) {
                    viewPlayerCard(event.target.dataset.playerId);
                }
            });

            // Event listener to move from private view to night phase
            document.getElementById('night-phase-button').addEventListener('click', () => {
                showSection('night-phase-section');
                setupNightActions();
                document.querySelectorAll('.night-btn').forEach(btn => btn.disabled = false); // Ensure night action buttons are enabled to start
                document.querySelectorAll('.night-btn').forEach(btn => btn.classList.remove('executed-skill', 'skipped-skill'));
            });

            // Event listeners for night skill actions
            document.getElementById('confirm-skill-button').addEventListener('click', confirmNightSkill);
            document.getElementById('skip-skill-button').addEventListener('click', skipNightSkill);

            // Event listener to move from night phase to day phase
            document.getElementById('day-phase-button').addEventListener('click', () => {
                showSection('day-phase-section');
                setupVotingOptions();
                state.activePlayerIndex = 0; // Reset for voting
                document.getElementById('cast-vote-button').textContent = `æŠ•ç¥¨ (${state.players[state.activePlayerIndex].name})`;
                document.getElementById('cast-vote-button').disabled = false;
                document.getElementById('show-results-button').style.display = 'none';
                document.getElementById('final-votes').style.display = 'none';
            });

            // Event listener for casting a vote
            document.getElementById('cast-vote-button').addEventListener('click', castVote);
            // Event listener for showing results after voting
            document.getElementById('show-results-button').addEventListener('click', showResults);

            // Event listener for restarting the game
            document.getElementById('restart-game-button').addEventListener('click', restartGame);


            // Initial setup on page load
            renderRoleSkills(); // Populate role summary table
            updatePlayerCount(playerCount); // Initialize player count and recommended config
            loadRecommendedConfig(playerCount); // Loads roles for default player count
            updateGameButtons(); // Initial state of game control buttons

        });
    </script>
</body>
</html>
